#!/usr/bin/php
<?php

namespace PhpPackage;

include __DIR__ . '/../vendor/autoload.php';

$DIR = realpath(__DIR__ . DIRECTORY_SEPARATOR . '..');
$generator = new Generator($DIR);
$generator->generate();

class Generator
{
    public $directory = '';
    public $options = [];
    public $excluded = [];
    public $replacements = [];
    public $files = [];
    public $buildPath = '';
    public $params = [
        'author' => [
            'description' => 'Enter the author.  Use all lowercase and no spaces, dashes, or underscores.',
            'example' => 'greatauthor'
        ],
        'project' => [
            'description' => 'Enter the project name. Use all lowercase and no spaces, dashes, or underscores.',
            'example' => 'greatproject'
        ],
        'camelcase' => [
            'description' => 'Enter the CamelCase version of the project name.  This is used for class naming so first character should be uppercase.',
            'example' => 'GreatProject'
        ],
        'description' => [
            'description' => 'Enter the description.  Used in readme',
            'example' => 'GreatProject authored by GreatAuthor'
        ],
        'namespace' => [
            'description' => 'Enter the namespace.',
            'example' => 'GreatOrg\GreatProject'
        ]
    ];

    public function __construct(string $directory)
    {
        if (!is_dir($directory)) {
            throw new \Exception('Directory is not valid.');
        }
        $this->directory = $directory;
        $this->loadOptions();
        $this->createDirectories();

        $this->replacements = [
            'phppackageauthor' => $this->getOption('author'),
            'phppackagename' => $this->getOption('project'),
            'PhpPackageNamespace' => $this->getOption('namespace'),
            'phppackagedescription' => $this->getOption('description'),
            'PhpPackageClass' => $this->getOption('camelcase'),
            'phpPackageName' => lcfirst($this->getOption('camelcase')),
            'phppackage' => $this->getOption('project'),
            'PhpPackage' => $this->getOption('camelcase'),
        ];

        $gitignored = file($directory . '/.gitignore', FILE_IGNORE_NEW_LINES);
        $this->excluded = array_unique(array_merge_recursive($gitignored, ['/.git', '/bin']));
        $this->files = $this->recurseFolders($directory, $this->excluded);
    }

    public function getOption(string $key): ?string
    {
        return (isset($this->options[$key])) ? $this->options[$key] : null;
    }

    public function loadOptions()
    {
        $longOptions = [];
        foreach ($this->params as $property => $definition) {
            $longOptions[] = $property . ':';
        }
        $this->options = getopt("", $longOptions);

        // interactive
        foreach ($this->params as $property => $definition) {
            while (empty($this->options[$property])) {
                $line = readline($definition['description'] . ' ' . $definition['example'] . ' $ ');
                $this->options[$property] = $line;
                $this->printLine($this->buildCliCommand() . PHP_EOL);
            }
        }

        if (count($this->options) <> count($this->params)) {
            $this->printLine("Error gathering arguments.");
            die(PHP_EOL);
        }

        $this->printLine($this->buildCliCommand() . PHP_EOL);

        $confirm = '';
        while (empty($confirm) || ($confirm <> 'y' && $confirm <> 'n')) {
            $confirm = readline('Generate new project? [y/n] $ ');
        }

        if ($confirm == 'n') {
            $this->printLine('Exiting');
            die(PHP_EOL);
        }

        return $this->options;
    }

    public function printLine($line)
    {
        $output = (is_string($line)) ? $line : var_export($line, true);
        print $output . PHP_EOL;
    }

    public function buildCliCommand()
    {
        $command = 'php generate';
        foreach ($this->params as $param => $definition) {
            $optionValue = $this->getOption($param);
            if (!empty($this->getOption($param))) {
                $command .= ' --' . $param . '="' . $optionValue . '"';
            }
        }
        return $command;
    }

    public function createDirectories(): bool
    {
        $buildFolder = $this->directory . '/build/' . $this->getOption('project');
        $this->buildPath = $buildFolder;
        shell_exec("rm -rf '$buildFolder'");
        return mkdir($buildFolder);
    }

    public function generate()
    {
        foreach ($this->files as $fileInfo) {
            $sourcePath = $fileInfo->getPathname();
            $destinationContents = $this->replaceInFile($sourcePath, $this->replacements);

            $pathInfo = pathinfo($fileInfo->getPathname());

            foreach ($this->replacements as $replacement => $value) {
                if ($pathInfo['filename'] == 'composer.json' && $replacement == 'PhpPackageNamespace') {
                    $value = str_replace("\\", "\\\\", $value);
                }
                $pathInfo['filename'] = str_replace($replacement, $value, $pathInfo['filename']);
            }
            // $replacement = $this->searchPartialKey($this->replacements, $pathInfo['filename']);
            // if (isset($this->replacements[$pathInfo['filename']])) {
            //     $pathInfo['filename'] = $this->replacements[$pathInfo['filename']];
            // }
            $newFileExtension = (!empty($pathInfo['extension'])) ? '.' . $pathInfo['extension'] : '';
            $newFilepath = str_replace($this->directory, '', $pathInfo['dirname'] . '/' . $pathInfo['filename'] . $newFileExtension);
            $destinationPath = $this->buildPath . $newFilepath;


            $this->printLine($sourcePath . ' > ' . $destinationPath);
            //destinationContents
            $this->filePutContents($destinationPath, $destinationContents);
        }
    }

    public function recurseFolders(string $directory, array $excluded)
    {
        $innerIterator = new \RecursiveDirectoryIterator($directory, \RecursiveDirectoryIterator::SKIP_DOTS);
        $iterator = new \RecursiveIteratorIterator(new \RecursiveCallbackFilterIterator($innerIterator, function ($file, $key, $iterator) use ($directory, $excluded) {
            $pathFromRoot = str_replace($directory, '', $file->getPathname());
            if ($this->isIgnored($excluded, $pathFromRoot)) {
                return false;
            }
            if ($iterator->hasChildren()) {
                return true;
            }
            return $file->isFile();
        }));
        $files = iterator_to_array($iterator);
        return $files;
    }



    public function replaceInFile(string $filePath, $replacements = [])
    {
        $contents = \file_get_contents($filePath);
        foreach ((array) $replacements as $match => $replacement) {
            $contents = str_replace($match, $replacement, $contents);
        }
        return $contents;
    }

    public function isIgnored(array $exclusions, string $pathname)
    {
        $ignored = $this->searchPartialValue($exclusions, $pathname);
        return ($ignored === false) ? false : true;
    }

    public function filePutContents($destination, $contents)
    {
        $path = pathinfo($destination);
        if (!file_exists($path['dirname'])) {
            mkdir($path['dirname']);
        }
        if (file_put_contents($destination, $contents) === false) {
            throw new \Exception('Could not write contents to ' . $destination);
        }
    }

    /**
     * Searches array values for partial match and returns key
     *
     * @param array $array
     * @param string $term
     */
    public function searchPartialValue(array $array, string $term)
    {
        foreach ($array as $index => $value) {
            if (is_string($value) && !empty($term) && strpos($term, $value) === 0) {
                return $index;
            }
        }
        return false;
    }

    /**
     * Searches array keys for partial match and returns value
     *
     * @param array $array
     * @param string $term
     */
    public function searchPartialKey(array $array, string $term)
    {
        foreach ($array as $index => $value) {
            if (is_string($value) && !empty($term) && strpos($index, $term) === 0) {
                return $value;
            }
        }
        return false;
    }
}
